**DISKUTIL(8)        BSD系统管理员手册      DISKUTIL(8)**



**名称**

   **diskutil --     修改、验证并修复本地磁盘**



**概要**

   `diskutil [quiet] verb [options]` 



**描述**

  diskutil操作本地磁盘的结构。它提供了关于分区方案、布局和磁盘格式的信息，并允许对它们进行管理。这包括硬盘、固态磁盘、光盘、磁盘镜像、APFS卷、磁心存储器卷和AppleRAID集。它通常操作整个卷，而非单个文件和目录。



**动词**

 以下列出了每个动词及其描述和单个参数。

 `list [-plist] [internal | external]  [physical|virtual] [device]`

​	罗列磁盘，包括内部及外部磁盘，整个磁盘和分区，以及多种虚拟或离线磁盘。

​	若没有给定参数，则会列出所有整个磁盘及它们的分区。你可以通过指定过滤参数(如以上的<u>internal</u>,和<u>device</u> 磁盘),来限制显示的磁盘数目。当用磁盘来限制时，你可以指定整个磁盘，如disk0;也可以指定它的任何分片，如disk0s3。但是，过滤只在整个磁盘级别进行(在这种情形下，disk0s3是disk0的同义词)。

​	若指定了-plist,则会展示属性列表，而非常见的用户可读输出。

​	脚本可以解译<u>diskutil list -plist</u>的结果，并使用<u>diskutil info -plist</u>及<u>diskutil listFilesystems -plist</u>来获取更详细的信息。

​	整个磁盘自顶而下的呈现，以单元(整个磁盘)号的数值顺序排列。然而，在整个磁盘的分区"sublist"中，顺序指示了实际在磁盘上的位置。所列出的第一个磁盘项代表这一分区——它位于最近接整个磁盘的起始位置处，以此类推。

​     当这样看时，**BSD磁盘标识符**的分片(分区)可能，在某种情形下，不会以数值顺序出现。这是正常的，并很可能是最近的**分区映射编辑操作**的结果——在该操作中，卷被保持安装。

​	 注意，**人类可读的输出**和**plist输出**都按以上描述的方式进行排序。

​	 参看以下的**DEVICES部分**——它描述了**设备规范可能采用的多种形式**和**所有的其他diskutil动词**。

`info | information [-plist]  device |  -all`

​	获取关于某个特定的整块磁盘或分区的信息。若指定了-plist,则将会显示一个属性列表，而非用户可读的正常输出。若指定了-all,则处理整个磁盘(整块磁盘和它们的分区)。

`activity`

连续地展示由**磁盘仲裁框架**(见**译者注1**)所报告的系统级的磁盘操作活动，直到被某个信号中断(例如，通过键入Control-C)。

这对于观察以下**系统级活动**由用处: **磁盘联机**或**被弹出**、磁盘上的卷被**安装**或**卸载**、**卷**被**重新命名**等。

但是，这一输出必须永远不被解析；相反，程序应该成为磁盘仲裁客户端。

对于调试信息，例如对应用程序——它们对已其已关注的磁盘活动持不同意见(尝试拒绝)——的监控，你必须使用diskarbitrationd守护进程的调试特性。需要这一信息的程序必须成为磁盘仲裁客户端。

 `listFilesystems [-plist]`

当使用擦除和分区动词时，显示diskutil中用于格式化的文件系统特性。它是完整特性集合的子集——这些特性是由安装在系统中的多个文件系统捆绑包导出的。同时显示的是一些代表常见特性的快捷别名。参见下面的格式部分，来获取更多详情。若指定了-plist,将会呈现一个属性列表，而非常见的用户可读输出。

`unmount | umount [force] device`

卸载单个卷。force将会强制卸载该卷.

`unmountDisk | umountDisk [force] device`

给定一个包含分区映射的磁盘，卸载它的所有卷。即，会尝试卸载——1.那些包含**文件系统卷**的**映射分区**；2.由**存储系统**输出的"**虚拟卷**",这些**存储系统**从映射的分区引入了数据。存储系统支持包括号APFS,AppleRAID和CoreStorage在内的类型。

Force命令将强制卸载卷。

你应该指定一整个磁盘，但即使你指定了一个分区，这整块磁盘的所有卷都会被尝试卸载。

`eject device`

弹出一个磁盘。

为了以下目的，媒体将会断开连接:1.用于文件系统的数据存储2.成为类似软件RAID或直接数据的结构的成员。另外，可移除的媒体将适于安全手动移除；自动可移除媒体将开始它的物理(机动化的)弹出序列。

`mount [readOnly]  [-mountPoint path]  device`

安装单个卷。若指定了readOnly选项，则会以只读方式安装文件系统，即使该卷的底层文件系统和(或)设备和（或)媒体支持写入；即使是超级用户可能也无法写入，这点和mount(8)的rdonly选项相同。

### 如果指定了-mountPoint，则该路径，而非/Volumes/卷名这个标准路径，

### will be used as the view into the volume file content;



### a directory at that path must already exist.



`eraseDisk format name [APM[Format] | MBR[Format] |GPT[Format]]  device`

**擦除**现存的**磁盘**，**清除**所有**卷**，并写入一个包含一个新的**空文件系统卷**的新分区方案。如果没有指定**分区方案**，

那么会为当前机器选择一个合适方案。在以下介绍分区磁盘动词的部分，会讨论**格式**。需要受影响磁盘的**所有权**。





APFS   | ap apfsVerb [...]

​		Apple APFS是一个虚拟卷的系统。APFS动词可用于创建、操作和销毁APFS容器和它们的APFS卷。Apple APFS定义了这些对象类型:

1.**容器**——一个APFS容器，它引入了一个或多个APFS物理存储硬盘，并导出了零个或多个APFS卷磁盘。在任一时刻，零个或多个APFS容器可存在于(可能被附加到)系统上。

当被附加到系统上时，用于标识APFS容器的句柄是用APFS引用磁盘(设备)标识的。你应该把它作为一个透明的引用令牌对待。

容器引用磁盘是一整块合成的磁盘，它由APFS导出，仅用于身份证明用途；它没有存储。它与**IO注册表**中的Apple APFS ContainerScheme节点相关联。虽然APFS卷设备标识符似乎具有相关联的形式，你决不应该使用容器引用作为基础，来为你自己创建设备标识符；相反，你应该使用带有plist选项的列表动词。

某个APFS容器有某一固定大小(容量)，它通过其物理存储(s),使用磁盘上的物理空间。可以调整某个APFS容器的大小，但这不是常规操作的一部分。

2.**物理存储**

APFS物理存储是一个磁盘，该磁盘被导入(即它支持，其实定义了)一个APFS容器。一个APFS容器可以导入多余一个物理存储，例如，用于融合式的容器。

一个APFS物理存储磁盘不必是来自分区映射的磁盘，例如，它可能是一个AppleRAID集合磁盘。因此，你决不能假设某个APFS物理存储的磁盘标识符是像disk0s2一样的2部分格式。

**3.卷**——APFS卷是一个可安装(可卸载的)文件系统卷，它从一个APFS容器中导出。零个或多个APFS卷，可能从一个APFS容器中被导出。

APFS 卷没有具体的"大小"(容量)。相反，所有的APFS卷消耗其父APFS容器中剩余可用空间的容量，消耗或返回添加或删除用户文件数据时的这些容量。注意，这意味着容器内的所有卷竞争容器的剩余容量。但是，你可以使用可选的**保留**和**配额**大小值来管理卷分配。

可选的保留大小请求用于APFS卷的确定最小容量。如果创建成功，该卷必定能够存储用户文件数据的至少这么多字节。注意除此之外，该卷也许能储存更多，直到其父容器没有可用空间或达到配额(如果有的话)。你可以使用一个**备用资源**来防止由于**来自其他卷的竞争**或**来自容器收缩尝试(Container shrink attempt)的竞争**而耗尽容量。

可选的**定额大小**在一个**APFS卷**上施加一个**最大容量**——对可以存储在卷上的**用户文件数据**的**字节数**设置了一个限制。注意，如果它的父容器首先变满，你可能无法达到这一限制。你可以使用一个**定额**来强制执行记帐或设法应对对父容器的"不公平的"**过早填充**——这以**牺牲兄弟卷**为代价 ，只用**当前卷**来**填充**。

**APFS卷**可以用零个或更多的**角色元数据标志**来标记——这些标志给出了关于它们的**预期用途**的提示。不是所有**标志的组合**都是有效的，且不是所有的**标志**都被允许由某个用户**设置**或**改变**。

支持高效的**文件复制克隆**(写时复制)(请参阅copyfile(3)的COPYFILE_CLONE部分)。

支持可选的文件级别的加密。

**APFS卷设备标识符**的格式，是特定全磁盘的片磁盘的格式；这两种磁盘都由APFS合成。"整个"标识符数(一个正的可能是多位整数)是任意的，而且"片"数(正的可能是多位整数)在每个新卷中，从1开始递增。删除卷可能会导致编号中出现间隙。这种格式表现得像**分区(映射)方案**和**分区**一样，但它是完全不相关的。例如，如果"disk3s2"是一个定义了容器的**物理存储**，那么"disk5s1","disk5s2",and "disk5s3" 可能是这个容器的卷；"disk5"存在但从未被直接使用。

虽然它有一个**设备节点**，一个**APFS卷**的数据可能只能通过它的**文件**来存取；你不能打开一个**APFS卷设备节点**来"直接"存取它的**磁盘字节**。

**4.快照**——**APFS快照**代表了其**父APFS卷**的只读副本，在创建之初就**冻结**了。某个**APFS卷**可以有**零个**或**多个**相关联的**APFS快照**。当未安装**APFS快照的卷**时，它们既不会被列出，也无法被发现。快照通过**数值标识符**(优选的)或通过**它们的名称**，在它们**父卷的命名空间**内，被**唯一标识**。可以**重命名快照**，但APFS将**决不允许**在同一个卷内出现**重复的名称**。

**APFS快照**是可挂载的；当**挂载**该快照时，它的**挂载点**(与其父卷分离，且同时发生)会在**创建快照**时，提供**卷内容**的一个**只读历史版本**。

你可以把**APFS卷**的当前状态恢复为与其历史中的**某一快照**相同的状态。这是一个破坏性的**重置/复原**操作：一旦复原了某卷，就无法恢复之前状态。在**恢复点**和**当前状态**之间的所有快照也丢失了。

你可以**删除**某个**快照**；这**消除了恢复**到那个快照状态的**可能性**，但并**不影响**这个卷的**当前时间内容**。

某个APFS快照挂载点的"**源设备**"不是一个常见的**设备节点**(如disk0s2);它是快照名称后跟'@'字符及"父"卷的设备节点，如"SnapName123@/dev/disk2s1"。

**5.卷组**

**APFS卷的集合**可以通过一个**APFS卷组**来相互关联。零个或多个**APFS卷组**可能存在于任何给定的**APFS容器**中。任意特定APFS卷组的"成员"(**APFS卷**)，必须处于同一个**APFS容器**中。

用**APFS卷组**的**卷组ID**(一个UUID)来标识它们。在某些情形下，这一ID的**分配**可能会**被延迟**。

**APFS卷组**的一个主要用途是**macOS安装的实现**，在安装时，"系统"-角色(用于操作系统)和"数据"-角色(用于用户数据)APFS卷必须被功能性链接，但因为安全、备份和软件更新的原因而被分离。

APFS本身并没有备份数据的规定。应该经常地执行备份，且应该在使用这些命令修改任何APFS容器之前备份。

以下是带有描述和单独参数的APFS子动词的列表。

`list [-plist] [containerReferenceDevice]`

​		以树的形式显示**APFS对象**。将显示**APFS容器**及其导入的**物理存储**和导出的**卷**。

​	    除非你指定了一个**containerReferenceDevice**——它限制了向特定**APFS容器族**的输出，否则系统中所有当前附加的**APFS容器**都会被罗列出来。

​		如果指定了-plist,那么将展示一个属性列表，而非正常的用户可读输出。

`convert device [-dryrun] [-prebootSource yourStagingDirectory] [-noPrebootAdditions]`

​		非破坏性地把一个**HFS卷**转换为带有单个**APFS卷**的**APFS容器**。该**APFS容器**在之后可被正常操作(如**添加和删除APFS卷**)。这一动词可以被用于转换**不可引导的仅有"数据"的卷**及**"macOS"卷**(参见如下)。

​		**源HFS卷**可位于**GPT分区**或某个加密或未加密的，融合的或非融合的**核心存储逻辑卷(LV)**。在后一种情形中，**核心存储逻辑卷组**(LVG)被拆解，包括自动清除任何相关的**Boot Camp辅助分区**。

### 。。。

`createContainer [-main] device [-secondary] [device]`



`deleteContainer [-force] containerReferenceDevice |physicalStoreDevice [name]`

**销毁**一个现存的**APFS容器**，包括它的**所有APFS卷**。你可以通过**APFS容器**的**容器引用磁盘**(优选的)，或通过它的**物理存储磁盘**来标识它。

**APFS卷**首先被卸载；如果一个或多个卷繁忙，则这一过程可能不会成功。若卸载失败，则会终止该操作，所有的东西都原封不动。否则，所有的**APFS卷**连同它的**APFS容器**都会被**删除**；且APFS容器以前的**物理存储磁盘**将会被重新格式化为**HFS**；所有**APFS卷**上的**数据**将会丢失。

你可以选择**指定一个新名称**，否则将会选择"**Untitled**"。如果有多个**物理存储**，会为每个存储添加一个**空间**和一个**数字后缀**。

如果你的**APFS容器**被损坏，则代表该容器的**容器应用**可能不存在或**该容器**可能不会起作用。在这种情形下，你可以通过指定**-force**选项来收回你之前的**APFS物理存储磁盘**，这激活了供替代的**"最后一招"模式**。在这一模式下，如果你有多于一个**物理存储**(如，融合情形)，而且该容器**被充分损坏**，你可能必须**手动删除**每个**物理存储**。你通常应该避免这一模式。需要受影响磁盘的所有权。

### 

### 示例

​		删除整块磁盘(设备)

​		diskutil **eraseDisk** JHFS+ Untitled disk3

​	

​              physicalStoreDevice **[****name****]**

### 译者注

 (1).磁盘仲裁框架提供了机制，用于注册安装/卸载通知及阻塞安装/卸载事件。

(参考链接:https://developer.apple.com/documentation/diskarbitration)









