# 反码

### 编译自[维基百科]([https://en.wikipedia.org/wiki/Ones%27_complement](https://en.wikipedia.org/wiki/Ones'_complement))

​		 二进制数的反码定义如下：通过反转该数的二进制表示法中的所有位（把0换成1，把1换成零）而获得的值。在某些算数操作中，一个数的反码起的作用类似于原始数的负数。

​		反码系统或反码算法是一个系统，在该系统中，负数被表示为其对应正数的二进制表示法的反转。在这种系统中，通过计算某个数的反码来对它进行取反（从正数变为负数或相反）。一个N位反码数值系统只能表示-(2^N-1^-1)到2^N-1^-1范围内的整数，而补码则可表示-2^N-1^到2^N-1^-1范围内的整数。

​		反码二进制数值系统的特征是，任何整数值的位补码都是该值的算数负数。即，对一个数的所有位取反（逻辑补码）的效果等同于从0中减去该数。

​		许多早期计算机（包括 [CDC 6600](https://en.wikipedia.org/wiki/CDC_6600), [LINC](https://en.wikipedia.org/wiki/LINC), [PDP-1](https://en.wikipedia.org/wiki/PDP-1), 和 [UNIVAC 1107](https://en.wikipedia.org/wiki/UNIVAC_1100/2200_series#1107)）都是用反码记数法。直到20世纪八十年代末，CDC 6600的后继型产品仍继续使用反码， UNIVAC ( [UNIVAC 1100/2200 series](https://en.wikipedia.org/wiki/UNIVAC_1100/2200_series))1107的后继型产品到现在还在用反码。但大多数当代计算机使用补码。

## 内容

1.[数字表示法](#num_representation)

2.[基本要点](#Basics)

3.[负零](#nagative_zero)

4.[避免负零](#avoiding_negative_zero)

### <span id="num_representation">数字表示法</span>

反码和符号-幅值记数法使用同样的简单二进制系统——正数。负数是对应正数值的位补码。最大正数值的特点是，符号位(高位)为0，其余位为1。最小负数值的特点是，符号位为1，所有其余位为0。以下这个表格显示了4位系统中所有可能的值，从-7到+7。

|      |  +   |  -   |
| :--: | :--: | :--: |
|  0   | 0000 | 1111 |
|  1   | 0001 | 1110 |
|  2   | 0010 | 1101 |
|  3   | 0011 | 1100 |
|  4   | 0100 | 1011 |
|  5   | 0101 | 1010 |
|  6   | 0110 | 1001 |
|  7   | 0111 | 1000 |

——注意：当测试零值时，+0和-0都会返回TRUE，当测试非零值时，+0和-0都会返回FALSE.

### <span id="Basics">基本要点</span>

​		把两个值相加很简单。只用对齐最低有效位上的值，然后相加，把任何进位都加到左一位的值上。如果该进位超过了数字的最左端，则就说它已经”环绕“了，这种情形被称为"**循环进位**"。当”循环进位“出现时，进位必须**被加回到最右边的那一位**。这种现象并不出现在补码算术中。

```
 0001 0110        22
+0000 0011	   3
==========	=====
 0001 1001	  25
```

​		加法与加法相似——区别在于，传播到左侧的是**借位**而**非进位**。如果借位超过了数字的最左端，就说它已经”环绕“了，这种情形被称为"循环借位”。当“循环借位”出现时，必须从最右边那位减去借位。这种现象并不出现在补码算术中。

```
  0000 0110 				  6
- 0001 0011				  19
==========				 ====
1 1111 0011				 -12    ——产生了一个循环借位，且中间结果的符号位是1。
- 0000 0001				   1	——从结果中减去循环借位
===========				 ====
  1111 0010				 -13	——正确结果(6 - 19 = -13)
```

容易证明，正值的位补码是正值的负值。19+3的计算结果与19-（-3）相同。

把3加到19上。

```
  0001 0011					  19
+ 0000 0011					   3
===========					 ====  
  0001 0110					  22	
```

从19中减去-3。

```
  0001 0011					   19
- 1111 1100					   -3
===========					 ====
1 0001 0111					   23	——产生了循环借位。
- 0000 0001					    1	--从结果中减去循环借位
===========					 ====
  0001 0110 			   	22	--正确结果 （19 - （-3）= 22）。
```

### <span id="nagative_zero">负零</span>

​		负零是带符号数的所有位都为1的情形。这遵从以下反码规则：当最左边那位为1时，这个值为负数；负数是某个数值的位补码。当计算时，这个值所起的作用和零一样。另一个值加上（或减去）负零，得到的结果等于原始值。

加上负零:

```
  0001 0110 						22
+ 1111 1111 						-0
===========						=====
1 0001 0101  						21		——产生了循环进位
+ 0000 0001						 1
===========						=====
  0001 0110					        22		——正确结果 （22 + （-0）=22）
```

减去负零:

```
  0001 0110						22
- 1111 1111						-0
===========						====
1 0001 0111						23	——产生了循环借位
- 0000 0001						 1
===========						====
  0001 0110						22	——正确结果  (22 - (-0) = 22)
```

在反码加法器中容易产生负零——只用把相同大小的正值和负值相加即可得到。

```
  0001 0110					          22
+ 1110 1001						 -22
===========						====
  1111 1111						  -0	——负零
```

虽然数学计算总会得到正确结果，但负零的副作用是软件必须测试负零。

### <span id="avoiding_negative_zero">避免负零</span>

​		如果用**补码减法器**来实现加法，则将不再产生负零。第一个操作数未经修改传递给减法运算，第二个操作数求补运算，则减法运算生成正确结果，避免了负零。前一个例子，把22和-22相加会产生-0。

```
  0001 0110		22		  0001 0110    22
+ 1110 1001  -22			 -0001 0110    22	
===========  ===  但是 			===========  === 
  1111 1111   -0			  0000 0000     0
  类似的，
  1110 1001  -22			  1110 1001    -22
+ 0001 0110   22			 -1110 1001    -22	
===========  ===  但是		        ===========   ====
  1111 1111   -0			  0000 0000 	 0
```



